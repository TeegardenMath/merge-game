<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }
        .shake {
            animation: shake 0.3s ease-in-out;
        }
        .flash-red {
            animation: flash-red 0.3s ease-in-out;
        }
        @keyframes flash-red {
            0%, 100% { border-color: inherit; }
            50% { border-color: #ef4444; }
        }
        
        @keyframes merge-pop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        @keyframes particle-burst {
            0% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translate(-50%, -50%) translate(var(--tx), var(--ty)) scale(0); 
                opacity: 0; 
            }
        }
        
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes scale-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes completed-pulse {
            0% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
            }
            50% { 
                transform: scale(1.08);
                box-shadow: 0 0 0 12px rgba(34, 197, 94, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
            }
        }
        
        @keyframes shine-sweep {
            0% { 
                background-position: -200% center;
            }
            100% { 
                background-position: 200% center;
            }
        }
        
        .completed-category {
            position: relative;
            border: 3px solid #22c55e !important;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3), inset 0 1px 3px rgba(255, 255, 255, 0.5) !important;
            animation: completed-pulse 0.6s ease-out;
        }
        
        .completed-category::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                120deg,
                transparent 0%,
                transparent 40%,
                rgba(255, 255, 255, 0.5) 50%,
                transparent 60%,
                transparent 100%
            );
            background-size: 200% 100%;
            border-radius: inherit;
            pointer-events: none;
            animation: shine-sweep 2s ease-in-out;
        }
        
        .particle {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: particle-burst 0.5s ease-out forwards;
            z-index: 999;
            pointer-events: none;
        }
        
        .sparkle {
            position: fixed;
            font-size: 20px;
            animation: sparkle 0.6s ease-out;
            pointer-events: none;
            z-index: 1000;
        }
        
        .scale-pulse {
            animation: scale-pulse 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Mutually exclusive category groups - categories in the same group won't appear together
        const MUTUALLY_EXCLUSIVE_GROUPS = {
          "rivers": ["Rivers of North America", "Rivers of Europe", "Rivers of Asia"],
          "countries": ["European Countries", "Asian Countries", "African Countries"],
          "mythology_gods": ["Greek Gods and Goddesses", "Roman Gods and Goddesses", "Norse Gods", "Egyptian Gods"],
          "visual_artists": ["Painters", "Sculptors"],
          "literature_shakespeare": ["Shakespeare Characters", "Shakespeare Plays"],
          "us_geography": ["U.S. States", "Rivers of North America", "U.S. State Capitals"]
        };

        const MergeGame = () => {
          // ALL HOOKS MUST BE AT THE TOP (React Rules of Hooks)
          // Load categories from external file
          const [CATEGORIES, setCATEGORIES] = React.useState(null);
          const [items, setItems] = useState([]);
          const [selected, setSelected] = useState([]);
          const [won, setWon] = useState(false);
          const [failedMerge, setFailedMerge] = useState(false);
          const [mergeAnimation, setMergeAnimation] = useState(null);
          const [isDailyPuzzle, setIsDailyPuzzle] = useState(true);
          const [randomPuzzleSize, setRandomPuzzleSize] = useState(45); // For random puzzles only
          const [currentPuzzleSize, setCurrentPuzzleSize] = useState(45); // Track active puzzle size
          
          React.useEffect(() => {
            fetch('categories.json')
              .then(response => response.json())
              .then(data => setCATEGORIES(data))
              .catch(error => console.error('Error loading categories:', error));
          }, []);
          
          // Wait for categories to load (AFTER all hooks are declared)
          if (!CATEGORIES) {
            return <div className="flex items-center justify-center min-h-screen">
              <div className="text-xl">Loading categories...</div>
            </div>;
          }
          
          // localStorage utilities (better than cookies for this use case)
          const saveGameState = (state) => {
            try {
              localStorage.setItem('mergeGameState', JSON.stringify(state));
            } catch (e) {
              console.error('Failed to save game state:', e);
            }
          };
          
          const loadGameState = () => {
            try {
              const saved = localStorage.getItem('mergeGameState');
              return saved ? JSON.parse(saved) : null;
            } catch (e) {
              console.error('Failed to load game state:', e);
              return null;
            }
          };
          
          const clearGameState = () => {
            try {
              localStorage.removeItem('mergeGameState');
            } catch (e) {
              console.error('Failed to clear game state:', e);
            }
          };
          
          // Get today's date string for daily puzzle
          const getTodayString = () => {
            const today = new Date();
            return `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()}`;
          };
          
          // Seeded random number generator for consistent daily puzzles
          const seededRandom = (seed) => {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
          };
          
          const createSeededShuffle = (array, seed) => {
            const arr = [...array];
            let currentSeed = seed;
            for (let i = arr.length - 1; i > 0; i--) {
              const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
              [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
          };

          // Color utilities
          const hslToRgb = (h, s, l) => {
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            return [
              Math.round((r + m) * 255),
              Math.round((g + m) * 255),
              Math.round((b + m) * 255)
            ];
          };
          
          const rgbToHsl = (r, g, b) => {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const l = (max + min) / 2;
            
            if (max === min) return [0, 0, l];
            
            const d = max - min;
            const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            let h;
            if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
            else if (max === g) h = ((b - r) / d + 2) * 60;
            else h = ((r - g) / d + 4) * 60;
            
            return [h, s, l];
          };
          
          const generateStartingColor = () => {
            // Generate a very pale pastel color for initial merges
            const hue = Math.random() * 360;
            const saturation = 0.15; // Very low saturation - barely colored
            const lightness = 0.95; // Very light - almost white
            return { h: hue, s: saturation, l: lightness };
          };
          
          const mixColors = (color1, color2, mergeCount) => {
            // Average the hues (accounting for circular nature)
            let h1 = color1.h;
            let h2 = color2.h;
            
            // Handle hue wrapping (shortest path around color wheel)
            if (Math.abs(h1 - h2) > 180) {
              if (h1 < h2) h1 += 360;
              else h2 += 360;
            }
            
            const avgHue = ((h1 + h2) / 2) % 360;
            
            // Average saturation and lightness
            const avgSat = (color1.s + color2.s) / 2;
            const avgLight = (color1.l + color2.l) / 2;
            
            // Gradually increase saturation based on merge count relative to puzzle size
            // Use square root to make changes more visible early on
            // Start at 0.15, max out at 0.60 for vivid but still readable colors
            const progress = Math.sqrt(mergeCount / currentPuzzleSize); // Use actual puzzle size!
            const saturationBoost = progress * 0.45; // 0 to 0.45 boost (0.15 â†’ 0.60)
            const newSaturation = Math.min(0.60, avgSat + saturationBoost);
            
            // Darken significantly as items merge for better contrast
            const lightnessAdjust = progress * 0.20; // Aggressive darkening (0.95 â†’ 0.75)
            const newLightness = Math.max(0.75, avgLight - lightnessAdjust);
            
            return { h: avgHue, s: newSaturation, l: newLightness };
          };
          
          const hslToString = (hsl) => {
            if (!hsl) return 'white';
            return `hsl(${hsl.h}, ${hsl.s * 100}%, ${hsl.l * 100}%)`;
          };

          // Validate categories on mount
          useEffect(() => {
            const invalidCategories = [];
            for (const [name, items] of Object.entries(CATEGORIES)) {
              if (items.length < 45) {
                invalidCategories.push(`${name} (${items.length} items)`);
              }
            }
            if (invalidCategories.length > 0) {
              console.error('INVALID CATEGORIES DETECTED:');
              invalidCategories.forEach(cat => console.error(`  - ${cat}`));
              alert(`Game cannot start: ${invalidCategories.length} categories have < 45 items. Check console for details.`);
            }
          }, []);
          
          // Load game state on mount
          useEffect(() => {
            const savedState = loadGameState();
            const todayString = getTodayString();
            
            console.log('=== LOADING GAME STATE ===');
            console.log('Today:', todayString);
            console.log('Saved state:', savedState);
            
            if (savedState) {
              // Check if it's a daily puzzle and if it's still today's puzzle
              if (savedState.isDailyPuzzle && savedState.dailyDate !== todayString) {
                // Saved daily puzzle is from a different day - start fresh daily puzzle
                console.log('Saved daily puzzle is old, starting new daily puzzle...');
                clearGameState();
                initializeGame(true);
              } else {
                // Restore saved state (either same-day daily puzzle or random puzzle)
                console.log('Restoring saved game state...');
                console.log('  - isDailyPuzzle:', savedState.isDailyPuzzle);
                console.log('  - currentPuzzleSize:', savedState.currentPuzzleSize);
                setItems(savedState.items || []);
                setWon(savedState.won || false);
                setIsDailyPuzzle(savedState.isDailyPuzzle);
                setCurrentPuzzleSize(savedState.currentPuzzleSize || 45);
                setRandomPuzzleSize(savedState.randomPuzzleSize || 45);
              }
            } else {
              // No saved state - start new daily puzzle
              console.log('No saved state, starting new daily puzzle...');
              initializeGame(true);
            }
          }, []);
          
          // Save game state whenever anything changes
          useEffect(() => {
            if (items.length > 0) {
              const gameState = {
                items: items,
                won: won,
                isDailyPuzzle: isDailyPuzzle,
                currentPuzzleSize: currentPuzzleSize,
                randomPuzzleSize: randomPuzzleSize,
                dailyDate: isDailyPuzzle ? getTodayString() : null,
                lastUpdated: new Date().toISOString()
              };
              saveGameState(gameState);
            }
          }, [items, won, isDailyPuzzle, currentPuzzleSize, randomPuzzleSize]);

          const initializeGame = (isDaily = false, customSize = null) => {
            const categoryNames = Object.keys(CATEGORIES);
            
            // Determine puzzle size
            const TARGET_CATEGORIES = isDaily ? 45 : (customSize || randomPuzzleSize);
            const ITEMS_PER_CATEGORY = isDaily ? 45 : (customSize || randomPuzzleSize);
            const TARGET_TOTAL_ITEMS = TARGET_CATEGORIES * ITEMS_PER_CATEGORY;
            
            // Set mode and current size
            setIsDailyPuzzle(isDaily);
            setCurrentPuzzleSize(TARGET_CATEGORIES);
            
            // Get seed for daily puzzle (hash of today's date)
            let seed = Math.random();
            if (isDaily) {
              const todayString = getTodayString();
              seed = todayString.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
              console.log(`Daily puzzle seed: ${seed} (${todayString})`);
            }
            
            console.log(`\n=== INITIALIZING ${isDaily ? 'DAILY' : 'RANDOM'} GAME ===`);
            console.log(`Size: ${TARGET_CATEGORIES} categories Ã— ${ITEMS_PER_CATEGORY} items = ${TARGET_TOTAL_ITEMS} total`);
            console.log(`Total available categories: ${categoryNames.length}`);
            
            // Retry logic - keep trying until we get exactly 2025 items
            let attempts = 0;
            const maxAttempts = 10;
            let finalItems = [];
            
            while (attempts < maxAttempts) {
              attempts++;
              console.log(`\n--- Attempt ${attempts} ---`);
              
              // Shuffle categories (seeded for daily puzzle)
              const shuffledCategories = isDaily 
                ? createSeededShuffle(categoryNames, seed + attempts)
                : [...categoryNames].sort(() => Math.random() - 0.5);
              
              // Select categories while respecting mutual exclusions
              const selectedCategories = [];
              const usedGroups = new Set();
              
              for (const category of shuffledCategories) {
                if (selectedCategories.length >= TARGET_CATEGORIES) break;
                
                // Check if this category has enough items (need buffer for duplicates)
                // For smaller puzzles, we can be more lenient with the buffer
                const minRequired = Math.max(ITEMS_PER_CATEGORY, 50);
                if (!CATEGORIES[category] || CATEGORIES[category].length < minRequired) {
                  continue;
                }
                
                // Check if this category is in a mutually exclusive group
                let groupKey = null;
                for (const [key, categories] of Object.entries(MUTUALLY_EXCLUSIVE_GROUPS)) {
                  if (categories.includes(category)) {
                    groupKey = key;
                    break;
                  }
                }
                
                // If it's in a group that we've already used, skip it
                if (groupKey && usedGroups.has(groupKey)) {
                  continue;
                }
                
                // Add this category and mark its group as used
                selectedCategories.push(category);
                if (groupKey) {
                  usedGroups.add(groupKey);
                }
              }
              
              console.log(`Selected ${selectedCategories.length} categories`);
              
              // Sort selected categories by size (smallest first) to maximize success
              // This way, small categories with many duplicates get first pick of items
              const sortedBySize = selectedCategories.sort((a, b) => {
                return CATEGORIES[a].length - CATEGORIES[b].length;
              });
              
              console.log(`Processing categories from smallest to largest...`);
              
              const allItems = [];
              const usedItems = new Set(); // Track items globally to prevent duplicates
              const categoryResults = [];
              
              sortedBySize.forEach(category => {
                const categoryItems = CATEGORIES[category];
                
                // Shuffle items (seeded for daily puzzle)
                const shuffled = isDaily
                  ? createSeededShuffle(categoryItems, seed + category.charCodeAt(0))
                  : [...categoryItems].sort(() => Math.random() - 0.5);
                
                // Select items, skipping any that have already been used
                const selected = [];
                for (const item of shuffled) {
                  if (!usedItems.has(item)) {
                    selected.push(item);
                    usedItems.add(item);
                    
                    if (selected.length >= ITEMS_PER_CATEGORY) {
                      break;
                    }
                  }
                }
                
                categoryResults.push({ category, count: selected.length });
                
                // Add whatever we got (even if less than 45)
                selected.forEach(item => {
                  allItems.push({
                    id: Math.random().toString(36).substr(2, 9),
                    category,
                    items: [item],
                    displayText: item,
                    color: null // Start with no color (white)
                  });
                });
              });
              
              // Check if we hit the target
              if (allItems.length === TARGET_TOTAL_ITEMS) {
                console.log(`\nâœ… SUCCESS! Got exactly ${TARGET_TOTAL_ITEMS} items on attempt ${attempts}`);
                // Shuffle the final items array (seeded for daily puzzle)
                finalItems = isDaily
                  ? createSeededShuffle(allItems, seed + 999999)
                  : allItems.sort(() => Math.random() - 0.5);
                break;
              } else {
                console.warn(`Attempt ${attempts}: Got ${allItems.length} items, need ${TARGET_TOTAL_ITEMS}. Retrying...`);
                
                // Show which categories fell short
                const shortCategories = categoryResults.filter(c => c.count < ITEMS_PER_CATEGORY);
                if (shortCategories.length > 0) {
                  console.warn(`Categories that didn't yield 45 items:`);
                  shortCategories.forEach(c => console.warn(`  - ${c.category}: ${c.count}/45 items`));
                }
              }
            }
            
            if (finalItems.length !== TARGET_TOTAL_ITEMS) {
              console.error(`\nâŒ FAILED to get ${TARGET_TOTAL_ITEMS} items after ${maxAttempts} attempts. Got ${finalItems.length} items.`);
              console.error(`The game will proceed but may not have exactly 2025 items.`);
            }
            
            // Final shuffle (seeded for daily puzzle)
            const shuffledItems = isDaily
              ? createSeededShuffle(finalItems, seed + 888888)
              : finalItems.sort(() => Math.random() - 0.5);
            
            setItems(shuffledItems);
            setSelected([]);
            setWon(false);
            // State will be saved automatically by the useEffect
          };

          const toggleSelect = (id) => {
            if (selected.includes(id)) {
              setSelected(selected.filter(s => s !== id));
            } else {
              if (selected.length === 2) {
                setSelected([id]);
              } else {
                const newSelected = [...selected, id];
                setSelected(newSelected);
                
                if (newSelected.length === 2) {
                  setTimeout(() => attemptMerge(newSelected), 100);
                }
              }
            }
          };
          
          const reshuffleLayout = () => {
            const shuffled = [...items].sort(() => Math.random() - 0.5);
            setItems(shuffled);
            setSelected([]); // Clear selection when reshuffling
          };

          const attemptMerge = (selectedIds) => {
            const [id1, id2] = selectedIds;
            const item1 = items.find(i => i.id === id1);
            const item2 = items.find(i => i.id === id2);
            
            if (item1.category === item2.category) {
              const mergedItems = [...item1.items, ...item2.items];
              const displayText = mergedItems.length <= 3 
                ? mergedItems.join(", ")
                : `${mergedItems.slice(0, 3).join(", ")}... [${mergedItems.length}]`;
              
              // Mix colors
              let newColor;
              if (!item1.color && !item2.color) {
                // Both white - generate starting color
                newColor = generateStartingColor();
              } else if (!item1.color || !item2.color) {
                // One white, one colored - boost the colored one based on new merge count
                const coloredItem = item1.color || item2.color;
                const progress = Math.sqrt(mergedItems.length / currentPuzzleSize);
                const saturationBoost = progress * 0.45;
                const newSaturation = Math.min(0.60, 0.15 + saturationBoost);
                const lightnessAdjust = progress * 0.20;
                const newLightness = Math.max(0.75, 0.95 - lightnessAdjust);
                
                newColor = {
                  h: coloredItem.h,
                  s: newSaturation,
                  l: newLightness
                };
              } else {
                // Both colored - mix them
                newColor = mixColors(item1.color, item2.color, mergedItems.length);
              }
              
              const newItem = {
                id: Math.random().toString(36).substr(2, 9),
                category: item1.category,
                items: mergedItems,
                displayText,
                color: newColor
              };
              
              // Find the index of the second selected item
              const id2Index = items.findIndex(i => i.id === id2);
              
              // Build new array: keep items before id2, insert merged item, skip both selected items
              const newItems = [];
              items.forEach((item, index) => {
                if (item.id === id1 || item.id === id2) {
                  // Skip the selected items
                  if (index === id2Index) {
                    // At position of second item, insert the merged item
                    newItems.push(newItem);
                  }
                } else {
                  newItems.push(item);
                }
              });
              
              setItems(newItems);
              setSelected([]);
              
              // Trigger animation AFTER DOM updates with new items
              setTimeout(() => {
                const mergedElement = document.querySelector(`[data-item-id="${newItem.id}"]`);
                if (mergedElement) {
                  const rect = mergedElement.getBoundingClientRect();
                  setMergeAnimation({
                    category: item1.category,
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                  });
                  
                  // Add scale pulse to the merged item
                  mergedElement.classList.add('scale-pulse');
                  setTimeout(() => mergedElement.classList.remove('scale-pulse'), 300);
                  
                  // Clear animation after 600ms
                  setTimeout(() => setMergeAnimation(null), 600);
                }
              }, 0);
              
              if (newItems.every(item => item.items.length === currentPuzzleSize)) {
                setWon(true);
              }
            } else {
              // Merge failed - show feedback
              setFailedMerge(true);
              setTimeout(() => {
                setFailedMerge(false);
                setSelected([]);
              }, 300);
            }
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-indigo-50 to-purple-50 p-8">
              <div className="max-w-7xl mx-auto">
                <div className="text-center mb-8">
                  <h1 className="text-4xl font-bold text-gray-800 mb-2">Merge Game</h1>
                  <p className="text-gray-600 mb-2">
                    Select two items from the same category to merge them. Win by creating piles of {currentPuzzleSize}!
                  </p>
                  {isDailyPuzzle && (
                    <p className="text-sm text-indigo-600 font-medium mb-4">
                      ðŸ“… Playing today's daily puzzle (45Ã—45 = 2025 items)
                    </p>
                  )}
                  {!isDailyPuzzle && (
                    <div className="mb-4">
                      <p className="text-sm text-green-600 font-medium mb-2">
                        ðŸŽ² Random puzzle ({randomPuzzleSize}Ã—{randomPuzzleSize} = {randomPuzzleSize * randomPuzzleSize} items)
                      </p>
                      <div className="flex items-center gap-3 justify-center">
                        <label className="text-sm text-gray-600">Size:</label>
                        <input 
                          type="range" 
                          min="10" 
                          max="45" 
                          value={randomPuzzleSize}
                          onChange={(e) => setRandomPuzzleSize(parseInt(e.target.value))}
                          className="w-48"
                        />
                        <span className="text-sm font-medium text-gray-700 w-16">{randomPuzzleSize}Ã—{randomPuzzleSize}</span>
                        <button
                          onClick={() => initializeGame(false, randomPuzzleSize)}
                          className="text-sm bg-green-100 text-green-700 px-3 py-1 rounded hover:bg-green-200 transition-colors"
                        >
                          Apply Size
                        </button>
                      </div>
                    </div>
                  )}
                  <div className="flex gap-3 justify-center">
                    <button
                      onClick={() => initializeGame(true)}
                      className="inline-flex items-center gap-2 bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      ðŸ“… {isDailyPuzzle ? 'Restart' : 'Play'} Daily Puzzle
                    </button>
                    <button
                      onClick={() => initializeGame(false)}
                      className="inline-flex items-center gap-2 bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors"
                    >
                      ðŸŽ² {isDailyPuzzle ? 'Play' : 'New'} Random Puzzle
                    </button>
                    <button
                      onClick={reshuffleLayout}
                      className="inline-flex items-center gap-2 bg-purple-600 text-white px-6 py-3 rounded-lg hover:bg-purple-700 transition-colors"
                    >
                      ðŸ”€ Reshuffle Layout
                    </button>
                  </div>
                </div>

                {won && (
                  <div className="bg-green-100 border-2 border-green-500 rounded-lg p-6 mb-6 text-center">
                    <h2 className="text-3xl font-bold text-green-800">ðŸŽ‰ You Won! ðŸŽ‰</h2>
                    <p className="text-green-700 mt-2">All {currentPuzzleSize} categories merged successfully!</p>
                  </div>
                )}

                <div className="bg-white rounded-xl shadow-lg p-6">
                  <div className="mb-4 text-sm text-gray-600">
                    Items remaining: {items.length} | Selected: {selected.length}/2
                  </div>
                  
                  <div className="flex flex-wrap gap-2 justify-center">
                    {items.map(item => {
                      const isCompleted = item.items.length === currentPuzzleSize;
                      
                      return (
                        <button
                          key={item.id}
                          data-item-id={item.id}
                          onClick={() => toggleSelect(item.id)}
                          style={{
                            backgroundColor: selected.includes(item.id) 
                              ? '#e0e7ff' // indigo-100 when selected
                              : hslToString(item.color)
                          }}
                          className={`
                            px-4 py-2 rounded-lg border-2 transition-all font-medium text-sm
                            ${isCompleted ? 'completed-category' : ''}
                            ${selected.includes(item.id) 
                              ? 'border-indigo-500 shadow-md scale-105' 
                              : isCompleted
                                ? '' // Border handled by completed-category class
                                : 'border-gray-300 hover:border-indigo-300 hover:shadow'
                            }
                            ${failedMerge && selected.includes(item.id) ? 'shake flash-red' : ''}
                          `}
                        >
                          <div className="text-center whitespace-nowrap">
                            {isCompleted && 'âœ“ '}{item.displayText}{isCompleted && ' âœ“'}
                          </div>
                        </button>
                      );
                    })}
                  </div>
                </div>
                
                {/* Merge Animation */}
                {mergeAnimation && (
                  <>
                    {/* Sparkle stars in corners */}
                    {[
                      { x: -25, y: -25 },
                      { x: 25, y: -25 },
                      { x: -25, y: 25 },
                      { x: 25, y: 25 },
                    ].map((pos, i) => (
                      <div
                        key={i}
                        className="sparkle"
                        style={{
                          left: `${mergeAnimation.x + pos.x}px`,
                          top: `${mergeAnimation.y + pos.y}px`,
                          animationDelay: `${i * 0.1}s`
                        }}
                      >
                        âœ¨
                      </div>
                    ))}
                  </>
                )}
              </div>
            </div>
          );
        };

        ReactDOM.render(<MergeGame />, document.getElementById('root'));
    </script>
</body>
</html>
